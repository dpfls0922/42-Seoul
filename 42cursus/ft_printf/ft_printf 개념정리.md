# ft_pritnf 개념 정리


putnbr와 putstr으로는 만족할 수 없기 때문에 만드는 함수

주로 가변 인자 (variadic arguments) 를 사용하는 방법에 대해 배울 것

## 1. printf 함수


### 1) printf 함수

- <stdio.h> 헤더파일 안에 있음
- int printf(const char *restrict format, …)로 정의됨

printf 함수는 매개 변수의 개수가 정해지지 않은 함수이다. 이렇게 매번 함수에 들어가는 인수의 개수가 변하는 것을 가변 인자라고 한다. 함수에서 가변 인자를 정의할 때는 고정 매개 변수가 한 개 이상 있어야 하며 고정 매개 변수 뒤에 ...을 붙여 매개 변수의 개수가 정해지지 않았는 표시를 해준다. 단, ... 뒤에는 다른 매개 변수를 지정할 수 없다.

고정 매개 변수가 아닌 ...로 받은 가변 인자들을 처리하려면 **stdarg.h**에 정의된 가변 인자 처리 매크로를 사용해야 한다.

## 2. 가변 인자


### 1) 가변 인자란?

- 인수의 개수와 타입이 미리 정해져 있지 않다는 뜻
- 헤더 파일 : <stdarg.h>
- printf 함수는 전달되는 인수의 개수와 타입이 모두 다르지만 정상적으로 컴파일 되고 실행됨
- 함수의 이름이나 원형, 고정 인수의 개수 등은 필요에 따라 마음대로 작성 가능하고, 마지막 인수 자리에 …만 있으면 가변 인수 함수가 됨

### 2) 가변 인수 함수의 활용

- 가변 인수 함수는 한 번 호출로 여러 개의 정보를 다양한 방법으로 다룰 수 있다는 면에서 편리함
- 특히 printf 함수는 다양한 타입의 변수들을 한꺼번에 출력할 수 있어 변수값을 확인해 볼 때 아주 유용함

```jsx
void varFunc(int fix, ...)
{
	va_list ap;
	va_start(ap, fix);
	while (모든 인수를 읽을 때까지){
		va_arg(ap, 인수타입);
	}
	va_end(ap);
}
```

### 3)  C 가변 인자 매크로 함수

```jsx
va_list   // 가변 인자 목록
va_start  // 가변 인자를 가져올 수 있도록 가변 인자 시작 주소 참조하는 포인터 설정
va_arg    // 가변 인자를 참조하는 포인터를 통해 역참조 후, 해당 데이터의 크기만큼 밀어 다음 인자를 참조
va_end    // 가변 인자를 모두 처리 후, 가변인자를 가리키는 포인터를 NULL로 초기화
va_copy   // 가변 인자 목록을 복사

위의 매크로들은 stdarg.h에 정의되어 있기 때문에 헤더를 추가해줘야 이용할 수 있음
```

### Part 1: va_list

```jsx
va_list ap
```

- `가변 인자 목록`을 의미하며, 가변 인자의 메모리 주소를 저장하는 포인터 변수임
- 함수로 전달되는 인수들은 스택에 저장되며, 함수는 스택에서 인수를 꺼내 씀
- 스택에 있는 인수를 읽을 때 포인터 연산을 해야 하는데 현재 읽고 있는 번지를 기억하기 위해 va_list 형의 포인터 변수 하나가 필요함
- 포인터 증감할 때 1바이트 씩 증감하도록 하기 위해 va_list 타입은 char*형으로 정의됨

### Part 2: va_start

```jsx
va_start(ap, 마지막 고정 인수)
```

- va_list 타입의 ap 포인터 변수가 `첫 번째 가변 인수를 가리키도록` 초기화 함
- 첫 번째 가변 인수의 번지를 조사하기 위해서 마지막 고정 인수를 전달함
- va_start 내부에서는 ap가 마지막 고정 인수 다음 번지를 가리키도록 해주므로 이후부터 ap 번지를 읽으면 순서대로 가변 인수를 읽을 수 있음

### Part 3: va_**arg**

```jsx
va_arg(ap, 인수타입)
```

- 가변 인수를 실제로 읽는 명령
- ap가 가르키는 곳에서 type 자료형 만큼 데이터를 읽어와 type 자료형으로 반환
- ap로 지정된 위치에서 지정된 type 값을 검색하고 리스트에서 다음 인수를 가리키도록 ap를 증가시켜 다음 인수가 시작되는 위치를 결정
- ap 번지에 있는 값이 어떤 타입인지를 지정해야 이 매크로가 값을 제대로 읽을 수 있으므로 두 번째 인자 값의 타입을 지정함
    - ap 위치에 있는 정수값을 읽고자 할 때 → va_arg(ap, int) 호출
    - ap 위치에 있는 실수값을 읽고자 할 때 → va_arg(ap, double) 호출
    - char, short의 경우에는 int로 대신 쓰고, float의 경우 double로 대신 써 준 뒤, 형 변환을 해줘야 함
        
        ex) char ch = (char) va_arg(ap, int);
        
- 그런데 int나 double 같이 값이 아닌 타입 이름이 어떻게 함수의 인수가 될 수 있을까?
    - va_arg는 함수가 아니라 매크로 함수이기 때문에 가능
    - va_arg의 두 번째 인수는 내부적으로 sizeof 연산자와 캐스트 연산자로 전달되기 때문에 타입명이 될 수 있음

### Part 4: va_**end**

```jsx
va_end(ap)
```

- 모든 인수가 검색된 후 va_list 타입의 포인터 변수를 NULL을 할당함
- 특정 메모리 공간을 참조하고 있는 `포인터`에 `NULL`을 할당하여 참조하는 공간이 없도록 만듦 (내용 정리)
    - 가변 인수를 다 읽은 후 뒷정리를 하는데 별다른 동작은 하지 않고, 실제로 없어도 지장 x
    - 이 명령이 필요한 이유는 호환성 때문인데 플랫폼에 따라서는 가변 인수를 읽은 후에 뒷처리를 해야 하는 경우도 있기 때문

### 4) 가변 인수 함수의 조건

- 가변 인수 함수는 반드시 하나 이상의 고정 인수를 가져야 함
    
    가변 인수를 읽기 위한 포인터 ap를 초기화하기 위해서 마지막 고정 인수의 번지를 알아야 하기 때문
    
- 함수 내부에서 자신에게 전달된 가변 인수의 개수를 알아야 함
    
    전달될 수 있는 인수의 개수에는 제한이 없으며 컴파일러는 함수가 호출될 때 인수의 개수를 점검하지 않음. 그래서 호출 측에서 가변 인수가 몇 개나 전달되었는지를 알려주지 않으면 함수 내부에서 인수의 개수를 알 수 있는 방법이 없음. 함수 스스로 인수의 개수를 파악할 수 있도록 호출 측이 정보를 제공해야 함
    
- 개수와 마찬가지로 함수 내부에서 각각의 가변 인수 타입을 알 수 있어야 함
    
    %d가 제일 처음 나왔으면 첫 번째는 정수, %f가 나오면 실수라는 것을 알게 됨
    
    가변 인수들의 타입을 알아야 하는 이유는 va_arg 매크로가 ap번지에서 가변 인수를 읽을 때 얼마만큼 읽어서 어떤 타입으로 해석해야 할지를 알아야 하기 때문
    
    가변 인수의 타입을 전달하는 방식도 여러 가지를 생각할 수 있는데 printf와 같이 하나의 고정 인수를 통해 모든 가변 인수의 타입을 판단할 수 있는 힌트를 제공하는 방식이 가장 좋음
    
    printf는 첫 번째 고정 인수로 전달되는 서식 문자열에서 %d, %f, %s 같은 서식의 개수만큼 가변 인수를 읽음으로써 사실상 가변 인수의 개수를 전달받음
    
    https://aossuper8.tistory.com/17
    

## 3. printf 형식 문자열


### 1) printf의 프로토타입

```jsx
int  printf(const char * format, ...)
```

- 반환값이 int 형으로 정의된 이유는 출력된 문자열의 수가 반환해야 되기 때문

printf의 고정 인수 format은 흔히 우리가 출력하고자 하는 문자열이고, 이 문자열 안에는 % 문자로 시작하는 `서식지정자`가 존재한다. **이 서식지정자에 다양한 플래그, 폭, 정밀도, 길이들의 옵션을 조합해서 사용할 수 있다.** 서식지정자에 옵션을 추가하려면 정해진 `형식 태그`의 형태를 지켜야 한다. printf의 형식 태그는 아래와 같다.

### 2) **형식**

```jsx
%[flags][width][.precision]type

// []로 둘러싸인 부분은 옵션이므로 생략할 수 있음
// 최소한의 형식 태그는 %type으로 구성
// 
```

- 형식 태그는 출력할 값, 즉 가변 인자에 대해 각각 적용되기 때문에 `형식 태그의 개수 ≤  가변 인자의 개수`

### 3) 옵션

- 옵션 설명
    
    ### flag
    
    - [#] 진법 형식에 맞게 0, 0x 0X를 추가
    - [0] width에 맞게 주어진 너비의 빈자리를 0으로 채움
    - [ ] 양수일 땐 +대신 공백, 음수일 땐 -출력
    - ['] 정수와 지수에 천 단위를 표시함 (2,000)
    - [+] 양수일 때 +, 음수일 때 - 표시
    - [-] 좌측 정렬
    
    ### width
    
    - [n] n은 양수이며, 출력될 길이
    - [*] 너비 값을 인자로 받음. 인자로 받은 너비보다 더 긴 값이 들어오면 원래 길이만큼 출력함
    
    ```jsx
    printf("%5d", 42);
    printf("%*d", 5, 42);
    
    // 위 두 코드는 같은 출력을 나타냄
    
    1) 너비 값 < 주어진 값의 길이
    printf("%*d", 2, 100);
    
    // 출력 결과 : 100
    // 주어진 너비 값 2를 무시하고 원래 값 100이 출력됨
    
    2)너비 값 ≥ 주어진 값의 길이
    printf("%*d", 2, 1);
    
    // 출력 결과 : (공백)1
    // 너비 값에 맞춰 우측 정렬을 수행함
    
    ```
    
    ### precision
    
    .만 사용된 경우
    
    - [cp] 정확도를 무시
    - [diouxX] flag필드로 0이 주어지면, 0옵션을 무시함
    - [feEgGaA] 소수점 아래를 출력하지 않고, 마지막 숫자는 반올림
    - [s] 문자열 출력하지 않음
    - [*s] 출력할 최대 길이를 인자로 받음
    
    .n이 입력된 경우 앞의 width를 무시하고 n 만큼 출력됨
    
    - [c] 정확도를 무시
    - [diouxX] 출력할 최대 자릿수를 지정, 출력값이 적은경우 남은 자릿수는 0으로 채움
    - [feEgGaA] 출력할 소수점 자릿수를 지정, 출력할 자리 직후의 숫자를 반올림
    - [s] 출력할 최대 문자열 길이를 지정
    - [p] 0x를 제외하고 총 길이로 주어진 n에 맞춰 출력

### 4) type

| type | 출력 형태 | 예시 |
| --- | --- | --- |
| c | 문자 | a |
| d or i | 부호 있는 10진법으로 나타난 정수 | 392 |
| s | 문자열 | sample |
| p | 포인터가 참조하고 있는 메모리의 주소 값 (8자리의 16진수) | 0x7ffeeb7c6afc |
| u | 부호없는 10진법으로 나타낸 정수 (unsigned int) | 7235 |
| x | 부호없는 16 진법으로 나타낸 정수 (소문자 사용) | 7fa |
| X | 부호없는 16 진법으로 나타낸 정수 (대문자 사용) | 7FA |
| % | %에 뒤이은 %를 이용하여 출력 스트림에 % 기호를 씀 | % |

printf는 출력에 성공하면 출력된 **전체 문자의 개수를 반환**한다. 출력에 실패하면 음수가 반환된다.

## 4. ft_printf 구현


### 1) 가변 인자 타입

각 서식지정자마다 가변 인자를 받아와서 사용하려면 서식지정자에 알맞은 데이터 타입을 va_arg  매크로 함수의 두 번째 매개 변수에 지정해줘야 한다.

1. 서식지정자 c, d, i

```jsx
va_arg(ap, int);
```

2. 서식지정자 s

```jsx
va_arg(ap, char *);
```

3. 서식지정자 u, x, X

```jsx
va_arg(ap, unsigned int);
```

4. 서식지정자 p

```jsx
va_arg(ap, void *);
```

### 2) ft_printf 파싱 과정

ft_printf 함수에 로직은 가변인자를 초기화 하는 부분에서 시작한다. 가변인자 한개를 받아오고 반복해서 아래의 로직을 실행한다.

1. %를 찾는다.
2. flag를 파싱한다. (여러 개가 존재하므로 반복문을 통해 파싱)
3. width를 파싱한다. (atoi 와 비슷하며  *을 고려해야한다.)
4. precision 파싱 (.을 먼저 파싱하고 width와 비슷한 과정을 진행한다.)
5. 파싱이 끝난 위치에 서식지정자가 있는지 확인하여 파싱 오류 체크 후 flag, width, precision이 모두 담긴 specifier 구조체와 가변인자를 인자로 넣어서 문자열에 이어서 나오는 서식지정자에 맞는 함수(ft_print_format)를 실행한다.

https://err0rcode7.github.io/42seoul/2021/01/14/ft_printf.html

## 5. C library printf()의 line buffering


```jsx
#include <stdio.h>
#include <unistd.h>

int main(void)
{
	printf("a");
	write(1, "b", 1);
	printf("c");
}

// 출력결과 bac
// printf() 함수를 먼저 작성하였지만 뒤에 작성한 write ()가 먼저 출력된 상황
```

- **printf() 함수보다 write()가 먼저 출력된  이유**
    
    printf() 함수는 line buffering을 사용하기 때문
    
- **Line Buffering이란?**
    
    버퍼에 개행 문자(’\n’)가 입력될 때마다 출력함
    
    즉, 개행문자가 들어오지 않는다면 버퍼에 계속 쌓아두다가 더 이상 실행할 명령이 없다면 해당 버퍼의 내용을 출력함